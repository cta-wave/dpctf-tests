<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title></title>
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src="../subtests/start-up-delay-should-be-sufficiently-low.js"></script>
    <script src="../subtests/playback-duration-matches-cmaf-track-duration.js"></script>
  </head>

  <body>
    <video style="height: 400px;"></video>
    <div>Press Enter/Ok to continue or Up/Down to show/hide debug overlay</div>
    <div id="debug"></div>
    <div id="log"></div>
    <div id="info-overlay"></div>
    <script src="../lib/mozilla/object-keys-polyfill.js"></script>
    <script src="../lib/stefanpenner/es6-promise.min.js"></script>
    <script src="../lib/utils/test_helper.js"></script>
    <script src="../lib/player.js"></script>
    <script src="../lib/manifest_parser.js"></script>
    <script src="../lib/mpd-parser.js"></script>
    <script src="../lib/info-overlay.js"></script>
    <script src="../lib/wave-service.js"></script>
    <script src="../lib/mse-support.js"></script>
    <script src="../lib/mime-codec-support.js"></script>
    <script>
      // Global variables
      var TEST_INFO = {
        title: "Switching Set Playback",
        description:
          "Playback of a switching set assumes that the application can switch across the fragments of different tracks without observing any temporal or spatial misalignment during playback.",
        path: location.pathname,
        params: urlParams,
        observations: [],
      };

      var waveService = null;
      var video = null;
      var player = null;
      var ignoreObservations = false;
      var resolveWaitForObservation = null;
      var resolveWaitingForResults = null;

      var tsMax = urlParams["tsMax"] || 120;
      var minBufferDuration = urlParams["min_buffer_duration"] || 30;
      var contentModel = "{{MPD_URL}}";
      var playout = urlParams["playout"] || 0;
      var token = urlParams["token"];

      // Specify workflow
      setupTest()
        .then(checkMseAvailable)
        .then(checkCodecs)
        .then(initializeWaveService)
        .then(sendTestReadyEvent)
        .then(waitForObservationReady)
        .then(executeTest)
        .then(waitForObservationResults)
        .then(handleError)
        .then(finishTest);

      function handleError(error) {
        if (!error) return;
        throw new Error(error);
      }

      function checkMseAvailable(error) {
        if (error) return error;
        log("Checking MSE API support");
        checkMseSupport();
        return Promise.resolve();
      }

      function checkCodecs(error) {
        if (error) return error;
        log("Checking Codec support");
        var manifest = player.getManifest();
        checkMimeAndCodecSupport(manifest);
        return Promise.resolve();
      }

      function setupTest(error) {
        if (error) return error;
        log("Setting up test");
        return new Promise(function (resolve) {
          //// Meta Info ////
          document.getElementsByTagName("title")[0].innerText = TEST_INFO.title;

          //// Configure Test Harness ////
          setup({
            explicit_timeout: true,
            explicit_done: true,
          });

          //// Player Setup ////
          video = document.querySelector("video");

          video.addEventListener("play", function (event) {
            var eventData = { type: "play" };
            waveService.sendSessionEvent(
              token,
              WaveService.PLAYBACK_EVENT,
              eventData
            );
          });

          video.addEventListener("ended", function (event) {
            var eventData = { type: "ended" };
            waveService.sendSessionEvent(
              token,
              WaveService.PLAYBACK_EVENT,
              eventData
            );
          });

          player = new Player(video);
          player.init({
            bufferTime: minBufferDuration,
            numberOfSegmentBeforePlay: 2,
          });

          player.load(contentModel);

          player.addEventListener("onManifestParsed", function (manifest) {
            var totalSegmentsCount = manifest
              .getRepresentation(playout)
              .getTotalSegmentsCount();
            player.setVideoSegments({
              representationNumber: playout,
              startSegment: 0,
              endSegment: totalSegmentsCount / 2 - 1,
            });
            playout++;
            if (playout >= totalSegmentsCount) {
              playout = 0;
            }
            player.setVideoSegments({
              representationNumber: playout,
              startSegment: totalSegmentsCount / 2,
              endSegment: totalSegmentsCount - 1,
            });
            player.startBuffering();
            resolve();
          });

          //// Info Overlay Setup ////
          var infoOverlayElement = document.getElementById("info-overlay");
          var infoOverlay = new InfoOverlay(infoOverlayElement);
          infoOverlay.init();

          document.addEventListener("keydown", function (event) {
            if (event.keyCode === 38) {
              infoOverlay.show();
            }
            if (event.keyCode === 40) {
              infoOverlay.hide();
            }
            if (event.keyCode === 13) {
              ignoreObservations = true;
              if (resolveWaitForObservation) resolveWaitForObservation();
              if (resolveWaitingForResults) resolveWaitingForResults();
            }
          });

          document.addEventListener("keydown", function (event) {
            if (event.keyCode === 13) {
              var repIndex =
                player
                  .getManifest()
                  .representations.indexOf(player.playingRepresentation) + 1;
              if (repIndex >= player.getManifest().representations.length) {
                repIndex = 0;
              }
              var totalSegmentsCount = player
                .getManifest()
                .getRepresentation(1)
                .getTotalSegmentsCount();
              player.setVideoSegments({
                representationNumber: repIndex,
                startSegment: player.getPlayingSegment().number,
                endSegment: totalSegmentsCount - 1,
              });
            }
          });

          player.addEventListener("onManifestParsed", function (manifest) {
            infoOverlay.updateOverlayInfo(player, TEST_INFO);
          });

          player.addEventListener("onTimeUpdate", function (currentTime) {
            infoOverlay.updateOverlayInfo(player, TEST_INFO);
          });

          player.addEventListener("onPlayingRepresentationChange", function (
            currentRepresentation
          ) {
            infoOverlay.updateOverlayInfo(player, TEST_INFO);
          });
        });
      }

      function executeTest(error) {
        if (error) return error;
        log("Executing test");
        return new Promise(function (resolve) {
          startUpDelaySmallEnough(tsMax);
          playbackDurationMatchesCMAFTrackDuration();

          if (player.getPreBufferedTime() >= minBufferDuration) {
            player.play();
          } else {
            player.addEventListener("onSegmentLoaded", function (event) {
              if (player.getPreBufferedTime() >= minBufferDuration) {
                player.play();
              }
            });
          }

          resolve();
        });
      }

      function initializeWaveService(error) {
        if (error) return error;
        log("Initializing WAVE service");
        return new Promise(function (resolve) {
          waveService = new WaveService();
          waveService
            .initialize("resources/wave-config")
            .then(function (error) {
              if (error) resolve("Failed to initialize wave service: " + error);
              resolve();
            });
        });
      }

      function sendTestReadyEvent(error) {
        if (error) return error;
        log("Sending test ready event");
        return new Promise(function (resolve) {
          if (!token) {
            resolve("No session token provided");
            return;
          }
          waveService
            .sendSessionEvent(token, WaveService.TEST_READY_EVENT, TEST_INFO)
            .then(function () {
              resolve();
            });
        });
      }

      function waitForObservationReady(error) {
        if (error) return error;
        if (ignoreObservations) return Promise.resolve();
        log("Waiting for observation framework to be ready");
        return new Promise(function (resolve) {
          resolveWaitForObservation = resolve;
          var listener = function (event) {
            if (event.type !== WaveService.OBSERVATION_READY_EVENT) return;
            if (event.data.test_path !== TEST_INFO.path) return;
            waveService.removeSessionEventListener(listener);
            resolve();
          };
          if (!token) {
            resolve("No session token provided");
            return;
          }
          waveService.addSessionEventListener(token, listener);
        });
      }

      function waitForObservationResults(error) {
        if (error) return error;
        if (ignoreObservations) return Promise.resolve();
        log("Waiting for observation results");
        return new Promise(function (resolve) {
          resolveWaitingForResults = resolve;
          var observations = TEST_INFO.observations;
          var observationResults = [];
          var listener = function (event) {
            if (event.type !== WaveService.OBSERVATION_COMPLETED_EVENT) return;
            observationResults = observationResults.concat(event.data);
            var allResultsReceived = true;
            for (var observation of observations) {
              var hasResult = false;
              for (var observationResult of observationResults) {
                if (observation.id !== observationResult.id) continue;
                hasResult = true;
                break;
              }
              if (hasResult) continue;
              allResultsReceived = false;
              break;
            }
            if (!allResultsReceived) return;
            waveService.removeSessionEventListener(listener);
            //tests.tests = tests.tests.concat(observationResults);
            resolve();
          };
          waveService.addSessionEventListener(token, listener);
        });
      }

      function finishTest() {
        done();
      }

      function log() {
        var text = "";
        for (var i = 0; i < arguments.length; i++) {
          text += arguments[i] + " ";
        }
        if (console && console.log) {
          console.log(text);
        }
      }
    </script>
  </body>
</html>
